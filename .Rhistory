if (stri_detect_fixed(lonlat, ",")) {
# split items into vector
vec <- unlist(strsplit(lonlat, ","))
resTemp$latitude[i] <- vec[2]
resTemp$longitude[i] <- vec[1]
}
}
}
# Merge lat/lon into tables
x$latitude <- with(resTemp, resTemp$latitude[match(x$location_id, resTemp$location_id)])
x$longitude <- with(resTemp, resTemp$longitude[match(x$location_id, resTemp$location_id)])
cat("Complete.\n")
cat(paste("Added coordinates to", orig - nrow(x[is.na(x$latitude), ]), "locations"))
} else{
cat("One or more coordinate columns missing")
}
} else{
cat("Parameter must be of type data.frame")
}
return(x)
}
locs2 <- geocode_census(locs)
View(locs2)
geocode_census <- function(x){
# Make sure input is data
if (class(x) == "data.frame"){
if("latitude" %in% colnames(x) & "longitude" %in% colnames(x) ){
cat("Starting Census Geocode...\n...\n")
p <- data.frame(x[is.na(x$latitude) | x$latitude =="", c(1,2,4,5,6)])
colnames(p) <- c("Unique_ID","Street address","City","State", "Zip")
orig <-  nrow(x[is.na(x$latitude) | x$latitude == "",])
apiurl <- "http://geocoding.geo.census.gov/geocoder/locations/addressbatch"
file <- tempfile(fileext = ".csv")
resTemp <- data.frame("location_id" = character(0), "latlon" = character(0))
# Census does not take batches where n > 1000
# Break up the locations into n = 500 bins and send separately
numBins <- ceiling(nrow(p) / 500)
placeHolder <- 0
pb <- txtProgressBar(1, numBins,style=3)
for( i in 1:numBins){
if (placeHolder + 500 > nrow(p)){
tmpBin <- p[placeHolder:(nrow(p)),]
}
else{
tmpBin <- p[placeHolder:(placeHolder+500),]
placeHolder <- placeHolder + 501
}
write.table(tmpBin, file, row.names=FALSE, col.names=FALSE, sep=",")
req <- POST(apiurl, body=list(
addressFile = upload_file(file),
benchmark = "Public_AR_Census2010",
vintage = "Census2010_Census2010"
),
encode = "multipart"
)
# Suppresses warning caused by census returning 3 columns when not found
suppressWarnings(resp <-
content(
req,
as = "parsed",
type = "text/csv",
encoding = "UTF-8"
))
if(ncol(resp) > 3 ){
# Workaround bug that sends a row to title
resp <- rbind(resp, names(resp))
resp <- resp[,c(1,6)]
names(resp) <- c("location_id", "latlon")
resTemp <- rbind(resTemp, resp)
}
setTxtProgressBar(pb, i)
}
# Separate lat/lon
resTemp$latitude <- ""
resTemp$longitude <- ""
for (i in 1:nrow(resTemp)) {
lonlat <- resTemp$latlon[i]
if (!is.na(lonlat)) {
# if there is a comma
if (stri_detect_fixed(lonlat, ",")) {
# split items into vector
vec <- unlist(strsplit(lonlat, ","))
resTemp$latitude[i] <- vec[2]
resTemp$longitude[i] <- vec[1]
}
}
}
# Merge lat/lon into tables
x$latitude <- with(resTemp, resTemp$latitude[match(x$location_id, resTemp$location_id)])
x$longitude <- with(resTemp, resTemp$longitude[match(x$location_id, resTemp$location_id)])
cat("Complete.\n")
cat(paste("Added coordinates to", orig - nrow(x[is.na(x$latitude), ]), "locations"))
} else{
cat("One or more coordinate columns missing")
}
} else{
cat("Parameter must be of type data.frame")
}
return(x)
}
locs2 <- ""
locs2 <- geocode_census(locs)
View(locs2)
p <- locs2[locs2$latitude != "",]
p <- locs2[is.na(locs2$latitude),]
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
query <- "DROP TABLE IF EXISTS location_output;"
tmp <- dbGetQuery(con, query)
source('main.R')
source('main.R')
source('main.R')
source('main.R')
View(locs)
query <- "SELECT * FROM location_output"
original <<- dbGetQuery(con, query)
View(original)
x <- original[original$latitude == "",]
View(x)
x <- original[is.na(original$latitude),]
View(x)
?min
lacking <- function(x){
print( x[1:min(20, nrow(x)),])
}
View(locs)
View(original)
View(original)
lacking(original)
lacking <- function(x){
y <- x[is.na(x$latitude) | x$latitude =="",]
print( y[1:min(20, nrow(y)),])
}
lacking(original)
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
source('main.R')
clear
clear()
source('main.R')
source('main.R')
source('main.R')
source('main.R')
View(locs)
View(origCopy)
View(locs)
write.csv(locs, "locs_output.csv", row.names=FALSE)
getwd
getwd()
setwd("C:/Users/rmiller/Desktop/GIS")
library(shiny); print(source('r_leaflet_test.R')$value)
install.packages("leaflet", dependencies=T)
m
m <- leaflet() %>%
addTiles() %>%
addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
library(leaflet)
m <- leaflet() %>%
addTiles() %>%
addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m
locs_output <- read.csv("C:/Users/rmiller/Desktop/gaia/locs_output.csv")
View(locs_output)
locs <- locs_output
m <- leaflet() %>%
addTiles() %>%
addMarkers(lng=locs$longitude[1], lat=locs$latitude[1], popup="The birthplace of R")
m
m <- leaflet() %>%
addTiles()
for (i in 1:20){
m <-addMarkers(lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
m <- leaflet() %>%
addTiles()
for (i in 1:20){
m <-addMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
m <- leaflet() %>%
addTiles()
for (i in 1:nrow(locs)){
m <-addMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
m <- leaflet() %>%
addTiles()
for (i in 1:100){
m <-addMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
m <- leaflet() %>%
addTiles()
for (i in 1:500){
m <-addMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
# Add circles to a map
df <- data.frame(Lat=1:10, Long=rnorm(10))
leaflet(df) %>% addCircles()
leaflet(df) %>% addCircles(lng = ~Long, lat= ~Lat)
install.packages("maps")
install.packages("maps")
library(maps)
mapStates = map("state", fill = TRUE, plot=FALSE)
leaflet(data= mapStates) %>%
addTiles() %>%
addPolygons(fillColor= topo.colors(10, alpha=NULL), stroke=FALSE)
library(leaflet)
library(maps)
mapStates = map("state", fill = TRUE, plot=FALSE)
leaflet(data= mapStates) %>%
addTiles() %>%
addPolygons(fillColor= topo.colors(10, alpha=NULL), stroke=FALSE)
# Map locations with different provider tiles
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
for (i in 1:100){
m <-addMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
# Add circle markers
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
for (i in 1:100){
m <-addCircleMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m
# Add circle markers
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
for (i in 1:100){
m <-addCircleMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m <- addMarkers(clusterOptions = markerClusterOptions())
m
# Add circle markers
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
for (i in 1:100){
m <-addCircleMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i])
}
m <- addMarkers(m,clusterOptions = markerClusterOptions())
m
?addMarkers
# Add circle markers
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
for (i in 1:100){
m <-addCircleMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i],clusterOptions = markerClusterOptions())
}
m
# cluster
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
for (i in 1:100){
m <-addMarkers(m, lng=locs$longitude[i], lat=locs$latitude[i], popup=locs$city[i],clusterOptions = markerClusterOptions())
}
m
# cluster
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
m <-addMarkers(m, ~longtitude, ~latitude, ~city,clusterOptions = markerClusterOptions())
m
# cluster
m <- leaflet() %>%
addProviderTiles("CartoDB.Positron")
m <-addMarkers(m, ~longtitude, ~latitude,popup= ~city)
m
# cluster
leaflet(data = locs) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(m, ~longtitude, ~latitude,popup= ~city)
# cluster
leaflet(data = locs) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(m, ~longitude, ~latitude,popup= ~city)
# cluster
leaflet(data = locs) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(~longitude, ~latitude,popup= ~city)
# much easier way to write the mapping
leaflet(data = locs) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs) %>%
addTiles("CartoDB.Positron") %>%
addMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs) %>%
addTiles() %>%
addMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs[1:100]) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs[1:100,]) %>%
addProviderTiles("CartoDB.Positron") %>%
addMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs[1:100,]) %>%
addProviderTiles("CartoDB.Positron") %>%
addCircleMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
# cluster
leaflet(data = locs[1:300,]) %>%
addProviderTiles("CartoDB.Positron") %>%
addCircleMarkers(~longitude, ~latitude,popup= ~city, clusterOptions=markerClusterOptions())
setwd("C:/Users/rmiller/Desktop/gaia")
location <- read.csv("C:/cdm_test_data/location.csv")
View(location)
View(location)
locs_output <- read.csv("C:/Users/rmiller/Desktop/gaia/locs_output.csv")
View(locs_output)
tail(locs_output)
x <- locs_output[locs_output$location_id == 1,]
View(x)
library(rgdal)
library(rgeos)
library(RODBC)
# Access database
library(RPostgreSQL)
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname="cdm", host="localhost", user="ohdsi_user", password="motech")
dbListTables(con)
# wasn't working with ST_X(ST_TRANSFORM(....)), the following is a placeholder
query <- "SELECT * FROM location"
locs <- dbGetQuery(con, query)
View(locs)
locs <- locs[1:3185,]
locs_output <- locs_output[1:3185,]
?dbWriteTable
dbWriteTable(con, "location", locs,  row.names=FALSE)
query <- "DROP TABLE location;"
tmp <- dbGetQuery(con, query)
dbWriteTable(con, "location", locs,  row.names=FALSE)
library(rgdal)
library(rgeos)
library(RODBC)
# Access database
library(RPostgreSQL)
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname="cdm", host="localhost", user="ohdsi_user", password="motech")
dbListTables(con)
# Import data from GIS
# 26919 psid for wells
# wasn't working with ST_X(ST_TRANSFORM(....)), the following is a placeholder
query <- "SELECT * FROM location"
locs <- dbGetQuery(con, query)
View(locs)
query <- "DROP TABLE location_output;"
tmp <- dbGetQuery(con, query)
# write table to database
dbWriteTable(con, "location_output", locs,  row.names=FALSE)
query <- "SELECT * FROM location_output"
locs <- dbGetQuery(con, query)
library(rgdal)
library(rgeos)
library(RODBC)
# Access database
library(RPostgreSQL)
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname="cdm", host="localhost", user="ohdsi_user", password="motech")
dbListTables(con)
locs <- dbGetQuery(con, query)
View(locs)
locs_output <- read.csv("C:/Users/rmiller/Desktop/gaia/locs_output.csv")
View(locs_output)
locs <- locs_output[1:3185,]
query <- "DROP TABLE location_output;"
tmp <- dbGetQuery(con, query)
# write table to database
dbWriteTable(con, "location_output", locs,  row.names=FALSE)
query <- "SELECT * FROM location_output;"
tmp <- dbGetQuery(con, query)
View(tmp)
states <- readOGR("C:/Users/rmiller/Desktop/GIS/cb_2015_us_county_20m.shp", layer="cb_2015_us_county_20m", verbose= FALSE)
mainePoly <- subset(states, states$STATEFP %in% c(
23
))
library(rgdal)
states <- readOGR("C:/Users/rmiller/Desktop/GIS/cb_2015_us_county_20m.shp", layer="cb_2015_us_county_20m", verbose= FALSE)
mainePoly <- subset(states, states$STATEFP %in% c(
23
))
locs_w_geo <- read.csv("C:/Users/rmiller/Desktop/gaia/locs_w_geo.csv")
View(locs_w_geo)
# Pull county polygons
states <- readOGR("C:/Users/rmiller/Desktop/GIS/cb_2015_us_county_20m.shp", layer="cb_2015_us_county_20m", verbose= FALSE)
# Subset to Maine
mainePoly <- subset(states, states$STATEFP %in% c(
23
))
locs_w_geo <- read.csv("C:/Users/rmiller/Desktop/gaia/locs_w_geo.csv")
counties <- substr(locs_w_geo$geoid,0,5)
cntyTable <- data.frame(table(counties))
mainePoly$NumRes <- with(cntyTable, cntyTable$Freq[match(mainePoly$GEOID, cntyTable$counties)])
pal <- colorBin(
palette = "Reds",
domain = mainePoly$NUMBER
)
leaflet(mainePoly) %>%
addPolygons(
stroke=FALSE, fillOpacity=0.5, smoothFactor = 0.5,
color = ~pal(NUMBER)
) %>%
addLegend("bottomright", pal=pal, values=~NUMBER)
counties <- substr(locs_w_geo$geoid,0,5)
cntyTable <- data.frame(table(counties))
mainePoly$NUMBER <- with(cntyTable, cntyTable$Freq[match(mainePoly$GEOID, cntyTable$counties)])
library(rgdal)
# Placeholders - should pull from DB
# Pull county polygons
states <- readOGR("C:/Users/rmiller/Desktop/GIS/cb_2015_us_county_20m.shp", layer="cb_2015_us_county_20m", verbose= FALSE)
# Subset to Maine
mainePoly <- subset(states, states$STATEFP %in% c(
23
))
locs_w_geo <- read.csv("C:/Users/rmiller/Desktop/gaia/locs_w_geo.csv")
counties <- substr(locs_w_geo$geoid,0,5)
cntyTable <- data.frame(table(counties))
mainePoly$NumRes <- with(cntyTable, cntyTable$Freq[match(mainePoly$GEOID, cntyTable$counties)])
View(cntyTable)
View(cntyTable)
View(cntyTable)
p <- merge(cntyTable, states, x= counties, y=GEOID)
p <- merge(cntyTable, states, x= counties, y=data.GEOID)
p <- merge(x= cntyTable, y=states, by.x = counties, by.y="GEOID")
p <- merge(x= cntyTable, y=states, by.x = counties, by.y=GEOID)
p <- merge(x= cntyTable, y=states)
View(p)
selRows <- cntyTable$counties %in% states$GEOID
table(selRows)
selRows <- states$GEOID %in% cntyTable$counties
table(selRows)
maine <- states[selRows,]
maine$NumRes <- with(cntyTable, cntyTable$Freq[match(mainePoly$GEOID, cntyTable$counties)])
maine$NumRes <- with(cntyTable, cntyTable$Freq[match(maine$GEOID, cntyTable$counties)])
pal <- colorBin(
palette = "Reds",
domain = mainePoly$Numres
)
leaflet(maine) %>%
addPolygons(
stroke=FALSE, fillOpacity=0.5, smoothFactor = 0.5,
color = ~pal(NumRes)
) %>%
addLegend("bottomright", pal=pal, values=~NumRes)
library(leaflet)
pal <- colorBin(
palette = "Reds",
domain = mainePoly$Numres
)
leaflet(maine) %>%
addPolygons(
stroke=FALSE, fillOpacity=0.5, smoothFactor = 0.5,
color = ~pal(NumRes)
) %>%
addLegend("bottomright", pal=pal, values=~NumRes)
setwd("C:/Users/rmiller/Desktop/RHC/RHC")
download.file(http://downloads.cms.gov/files/hcris/HOSP10FY2011.zip, "HOSP2011.zip")
download.file("http://downloads.cms.gov/files/hcris/HOSP10FY2011.zip", "HOSP2011.zip")
p <- unz(temp, "avc")
temp <- tempFile()
download.file("http://downloads.cms.gov/files/hcris/HOSP10FY2011.zip", temp)
temp <- tempfile()
download.file("http://downloads.cms.gov/files/hcris/HOSP10FY2011.zip", temp)
p <- unz(temp)
p <- unzip(temp)
p <- unz(temp, "hosp10_2011_ALPHA.csv")
p <- read.table(unz(temp, "hosp10_2011_ALPHA.csv"))
p <- read.table(unz(temp, "hosp10_2011_ALPHA"))
p <- data.table(unz(temp, "hosp10_2011_ALPHA"))
p <- data.frame(unz(temp, "hosp10_2011_ALPHA"))
p <- data.frame(unz(temp, "hosp10_2011_ALPHA.csv"))
p <-unz(temp, "hosp10_2011_ALPHA.csv")
p
p <-unzip(temp, "hosp10_2011_ALPHA.csv")
p <-unzip(temp)
p <-unzip(temp)
p1 <- unz(p[1])
p1 <- unz(temp,p[1])
p <-unzip(temp)p1
p1
unzip(temp)
p1 <- unz("HOSP2011.zip")
p1 <- unzip("HOSP2011.zip")
p1
p1 <- unz("HOSP2011.zip", "./hosp10_2011_ALPHA.CSV")
?gzfile
p1 <- gzfile("HOSP2011.zip")
p1
p1 <- gzfile("HOSP2011.zip", "w")
p1
readLines(zz <- gzfile("HOSP2011.zip"))
